-- globals:
--  log: s => ()
--  warn: s => ()
--  err: s => ()
--
--  duration: float [seconds] :: [0,+inf)
--  grid: BattleGrid

-- @return success_flag: bool
function start()
  warn("TODO: Make async?")
  warn("TODO: Get ref to Tackle: AnimatedSprite")

  return true
end

-- source: CellData
-- @return cells: { {x: int, y: int} }
function get_candidate_cells(source)
  local cell = source.cell
  local x = cell.x
  local y = cell.y

  warn("TODO: Helper function for these types of constructs\n" ..
       " => addv(vec2 a, vec2 b) -> vec2\n" ..
       " => zip(addv, [vec2] as, [vec2] bs) -> [vec2]")

  return {
    { x = x - 1, y = y + 1 },
    { x = x    , y = y + 1 },
    { x = x + 1, y = y + 1 },
    { x = x - 1, y = y - 1 },
    { x = x + 1, y = y - 1 }
  }
end

local duration = 0.5
local source_position
local target_position

-- @params
--  source: celldata
-- @return void
function before_animation(source, target)
  source_position = source.cell

  -- HACK: Convert Vector2Int -> Vector3
  target_position = {
    x = target.cell.x,
    y = target.cell.y,
    z = 0.0
  }

  if target.has_actor then
    target.actor:take_health(1)
  end
end

-- @params
--  source: celldata
-- @return void
function after_animation(source, target)
  source.actor.view_position = {
    x = source_position.x,
    y = source_position.y,
    z = 0.0
  }
end

-- @params
--  source: CellData
--  target: CellData
--  seconds: float :: [0,+inf)
-- @return void
function animate(source, target, seconds)
  -- log("TODO: Add method to end animation early")
  -- log("TODO: Helper function for procedural animations\n" ..
  --     "      such as 'hurt', 'death', 'heal', etc.")

  local t = seconds / duration

  -- BUG: Error for target_position
  if target.has_actor then
    proc.hurt(target.actor, target_position, t)
  end

  local from = source.cell
  local to = target.cell

  source.actor.view_position = {
    x = proc.boomerang_cubic(from.x, to.x, t),
    y = proc.boomerang_cubic(from.y, to.y, t),
    z = 0.0
  }

  return t < 1.0
end