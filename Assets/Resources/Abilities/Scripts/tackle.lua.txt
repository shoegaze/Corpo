-- globals:
--  log: s => ()
--  warn: s => ()
--  err: s => ()
--
--  duration: float [seconds] :: [0,+inf)
--  grid: BattleGrid

-- @return success_flag: bool
function start()
  warn("TODO: Make async?")
  warn("TODO: Get ref to Tackle: AnimatedSprite")

  return true
end

-- source: CellData
-- @return cells: { {x: int, y: int} }
function get_candidate_cells(source)
  local cell = source.cell
  local x = cell.x
  local y = cell.y

  warn("TODO: Helper function for these types of constructs\n" ..
       " => addv(vec2 a, vec2 b) -> vec2\n" ..
       " => zip(addv, [vec2] as, [vec2] bs) -> [vec2]")

  return {
    { x = x - 1, y = y + 1 },
    { x = x    , y = y + 1 },
    { x = x + 1, y = y + 1 },
    { x = x - 1, y = y - 1 },
    { x = x + 1, y = y - 1 }
  }
end

local source_position
local target_position

-- @params
--  source: celldata
-- @return void
function before_animation(source, target)
  source_position = source.cell
  target_position = target.cell

  if target.has_actor then
    target.actor:take_health(1)
  end
end

-- @params
--  source: celldata
-- @return void
function after_animation(source, target)
  source.actor.view_position = {
    x = source_position.x,
    y = source_position.y,
    z = 0.0
  }
end

-- @params
--  source: CellData
--  target: CellData
--  t: float :: [0,1]
-- @return void
function animate(source, target, t)
  -- log("TODO: Helper function for procedural animations\n" ..
  --     "      such as 'hurt', 'death', 'heal', etc.")

  if target.has_actor then
    proc.hurt(target.actor, target_position, t)
  end

  local from = source.cell
  local to = target.cell

  source.actor.view_position = {
    x = proc.boomerang_cubic(from.x, to.x, t),
    y = proc.boomerang_cubic(from.y, to.y, t),
    z = 0.0
  }
end