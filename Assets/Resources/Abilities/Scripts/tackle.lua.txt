-- globals:
--  log: s => ()
--  warn: s => ()
--  err: s => ()
--
--  math: Lua.Math
--  proc: Animation.Procedural
--
--  grid: BattleGrid

-- @return success_flag: bool
function start()
  warn("TODO: Make async?")
  warn("TODO: Get ref to Tackle: AnimatedSprite")

  return true
end

-- source: CellData
-- @return cells: { {x: int, y: int} }
function get_candidate_cells(source)
  local cell = source.cell
  local x = cell.x
  local y = cell.y

  warn("TODO: Helper function for these types of constructs\n" ..
       " => addv(vec2 a, vec2 b) -> vec2\n" ..
       " => zip(addv, [vec2] as, [vec2] bs) -> [vec2]")

  return {
    { x = x - 1, y = y + 1 },
    { x = x    , y = y + 1 },
    { x = x + 1, y = y + 1 },
    { x = x - 1, y = y - 1 },
    { x = x + 1, y = y - 1 }
  }
end

local duration = 0.5
local source_position
local target_position

-- @params
--  source: celldata
-- @return void
function before_animation(source, target)
  source_position = math.to_vector_3(source.cell)
  target_position = math.to_vector_3(target.cell)

  if target.has_actor then
    target.actor:take_health(1)
  end
end

-- @params
--  source: celldata
-- @return void
function after_animation(source, target)
  source.actor.view_position = source_position
end

-- @params
--  source: CellData
--  target: CellData
--  seconds: float :: [0,+inf)
-- @return bool
function animate(source, target, seconds)
  -- log("TODO: Helper function for procedural animations\n" ..
  --     "      such as 'hurt', 'death', 'heal', etc.")
  -- log("TODO: Math utilites e.g. min, max, clamp")

  local t = seconds / duration

  if target.has_actor then
    local t = 2.0 * math.saturate(t - 0.5)
    proc.hurt(target.actor, target_position, t)
  end

  local from = source.cell
  local to = target.cell

  source.actor.view_position = {
    x = proc.boomerang_cubic(from.x, to.x, t),
    y = proc.boomerang_cubic(from.y, to.y, t),
    z = 0.0
  }

  return t < 1.0
end